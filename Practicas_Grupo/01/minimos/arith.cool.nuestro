#name "arith.cool"
 A
 OBJECTID contribution
 OBJECTID from
 ANNE
 SHEETS
 OBJECTID sheets
 OBJECTID cory
 TESTS
 OBJECTID the
 OBJECTID arithmetic
 OBJECTID operations
 OBJECTID and
 OBJECTID various
 OBJECTID other
 OBJECTID things
 OBJECTID class
 A
 OBJECTID var
 INT
 ASSIGN
 INT_CONST 0
 OBJECTID value
 INT
 OBJECTID var
 OBJECTID set_var
 OBJECTID num
 INT
 SELF
 TYPE
 OBJECTID var
 ASSIGN
 OBJECTID num
 OBJECTID self
 OBJECTID method1
 OBJECTID num
 INT
 SELF
 TYPE
 OBJECTID same
 OBJECTID self
 OBJECTID method2
 OBJECTID num1
 INT
 OBJECTID num2
 INT
 B
 OBJECTID plus
 OBJECTID let
 OBJECTID x
 INT
 OBJECTID in
 OBJECTID x
 ASSIGN
 OBJECTID num1
 OBJECTID num2
 OBJECTID new
 B
 OBJECTID set_var
 OBJECTID x
 OBJECTID method3
 OBJECTID num
 INT
 C
 OBJECTID negate
 OBJECTID let
 OBJECTID x
 INT
 OBJECTID in
 OBJECTID x
 ASSIGN
 OBJECTID num
 OBJECTID new
 C
 OBJECTID set_var
 OBJECTID x
 OBJECTID method4
 OBJECTID num1
 INT
 OBJECTID num2
 INT
 D
 OBJECTID diff
 OBJECTID if
 OBJECTID num2
 OBJECTID num1
 OBJECTID then
 OBJECTID let
 OBJECTID x
 INT
 OBJECTID in
 OBJECTID x
 ASSIGN
 OBJECTID num1
 OBJECTID num2
 OBJECTID new
 D
 OBJECTID set_var
 OBJECTID x
 OBJECTID else
 OBJECTID let
 OBJECTID x
 INT
 OBJECTID in
 OBJECTID x
 ASSIGN
 OBJECTID num2
 OBJECTID num1
 OBJECTID new
 D
 OBJECTID set_var
 OBJECTID x
 OBJECTID fi
 OBJECTID method5
 OBJECTID num
 INT
 E
 OBJECTID factorial
 OBJECTID let
 OBJECTID x
 INT
 ASSIGN
 INT_CONST 1
 OBJECTID in
 OBJECTID let
 OBJECTID y
 INT
 ASSIGN
 INT_CONST 1
 OBJECTID in
 OBJECTID while
 OBJECTID y
 LE
 OBJECTID num
 OBJECTID loop
 OBJECTID x
 ASSIGN
 OBJECTID x
 OBJECTID y
 OBJECTID y
 ASSIGN
 OBJECTID y
 INT_CONST 1
 OBJECTID pool
 OBJECTID new
 E
 OBJECTID set_var
 OBJECTID x
 OBJECTID class
 B
 OBJECTID inherits
 A
 B
 OBJECTID is
 OBJECTID a
 OBJECTID number
 OBJECTID squared
 OBJECTID method5
 OBJECTID num
 INT
 E
 OBJECTID square
 OBJECTID let
 OBJECTID x
 INT
 OBJECTID in
 OBJECTID x
 ASSIGN
 OBJECTID num
 OBJECTID num
 OBJECTID new
 E
 OBJECTID set_var
 OBJECTID x
 OBJECTID class
 C
 OBJECTID inherits
 B
 OBJECTID method6
 OBJECTID num
 INT
 A
 OBJECTID negate
 OBJECTID let
 OBJECTID x
 INT
 OBJECTID in
 OBJECTID x
 ASSIGN
 OBJECTID num
 OBJECTID new
 A
 OBJECTID set_var
 OBJECTID x
 OBJECTID method5
 OBJECTID num
 INT
 E
 OBJECTID cube
 OBJECTID let
 OBJECTID x
 INT
 OBJECTID in
 OBJECTID x
 ASSIGN
 OBJECTID num
 OBJECTID num
 OBJECTID num
 OBJECTID new
 E
 OBJECTID set_var
 OBJECTID x
 OBJECTID class
 D
 OBJECTID inherits
 B
 OBJECTID method7
 OBJECTID num
 INT
 BOOL
 OBJECTID divisible
 OBJECTID by
 INT_CONST 3
 OBJECTID let
 OBJECTID x
 INT
 ASSIGN
 OBJECTID num
 OBJECTID in
 OBJECTID if
 OBJECTID x
 INT_CONST 0
 OBJECTID then
 OBJECTID method7
 OBJECTID x
 OBJECTID else
 OBJECTID if
 INT_CONST 0
 OBJECTID x
 OBJECTID then
 OBJECTID true
 OBJECTID else
 OBJECTID if
 INT_CONST 1
 OBJECTID x
 OBJECTID then
 OBJECTID false
 OBJECTID else
 OBJECTID if
 INT_CONST 2
 OBJECTID x
 OBJECTID then
 OBJECTID false
 OBJECTID else
 OBJECTID method7
 OBJECTID x
 INT_CONST 3
 OBJECTID fi
 OBJECTID fi
 OBJECTID fi
 OBJECTID fi
 OBJECTID class
 E
 OBJECTID inherits
 D
 OBJECTID method6
 OBJECTID num
 INT
 A
 OBJECTID division
 OBJECTID let
 OBJECTID x
 INT
 OBJECTID in
 OBJECTID x
 ASSIGN
 OBJECTID num
 INT_CONST 8
 OBJECTID new
 A
 OBJECTID set_var
 OBJECTID x
 THE
 OBJECTID following
 OBJECTID code
 OBJECTID is
 OBJECTID from
 OBJECTID atoi
 OBJECTID cl
 OBJECTID in
 OBJECTID cs164
 OBJECTID examples
 THE
 OBJECTID class
 A
 INT_CONST 2
 I
 OBJECTID provides
 OBJECTID integer
 OBJECTID to
 OBJECTID string
 OBJECTID and
 OBJECTID string
 OBJECTID to
 OBJECTID integer
 OBJECTID conversion
 OBJECTID routines
 TO
 OBJECTID use
 OBJECTID these
 OBJECTID routines
 OBJECTID either
 OBJECTID inherit
 OBJECTID them
 OBJECTID in
 OBJECTID the
 OBJECTID class
 OBJECTID where
 OBJECTID needed
 OBJECTID have
 OBJECTID a
 OBJECTID dummy
 OBJECTID variable
 OBJECTID bound
 OBJECTID to
 OBJECTID something
 OBJECTID of
 OBJECTID type
 A
 INT_CONST 2
 I
 OBJECTID or
 OBJECTID simpl
 OBJECTID write
 OBJECTID new
 A
 INT_CONST 2
 I
 OBJECTID method
 OBJECTID argument
 OBJECTID c2i
 CONVERTS
 OBJECTID a
 INT_CONST 1
 OBJECTID character
 OBJECTID string
 OBJECTID to
 OBJECTID an
 OBJECTID integer
 ABORTS
 OBJECTID if
 OBJECTID the
 OBJECTID string
 OBJECTID is
 OBJECTID not
 INT_CONST 0
 OBJECTID through
 INT_CONST 9
 OBJECTID class
 A
 INT_CONST 2
 I
 OBJECTID c2i
 OBJECTID char
 STRING
 INT
 OBJECTID if
 OBJECTID char
 INT_CONST 0
 OBJECTID then
 INT_CONST 0
 OBJECTID else
 OBJECTID if
 OBJECTID char
 INT_CONST 1
 OBJECTID then
 INT_CONST 1
 OBJECTID else
 OBJECTID if
 OBJECTID char
 INT_CONST 2
 OBJECTID then
 INT_CONST 2
 OBJECTID else
 OBJECTID if
 OBJECTID char
 INT_CONST 3
 OBJECTID then
 INT_CONST 3
 OBJECTID else
 OBJECTID if
 OBJECTID char
 INT_CONST 4
 OBJECTID then
 INT_CONST 4
 OBJECTID else
 OBJECTID if
 OBJECTID char
 INT_CONST 5
 OBJECTID then
 INT_CONST 5
 OBJECTID else
 OBJECTID if
 OBJECTID char
 INT_CONST 6
 OBJECTID then
 INT_CONST 6
 OBJECTID else
 OBJECTID if
 OBJECTID char
 INT_CONST 7
 OBJECTID then
 INT_CONST 7
 OBJECTID else
 OBJECTID if
 OBJECTID char
 INT_CONST 8
 OBJECTID then
 INT_CONST 8
 OBJECTID else
 OBJECTID if
 OBJECTID char
 INT_CONST 9
 OBJECTID then
 INT_CONST 9
 OBJECTID else
 OBJECTID abort
 INT_CONST 0
 OBJECTID the
 INT_CONST 0
 OBJECTID is
 OBJECTID needed
 OBJECTID to
 OBJECTID satisfy
 OBJECTID the
 OBJECTID typchecker
 OBJECTID fi
 OBJECTID fi
 OBJECTID fi
 OBJECTID fi
 OBJECTID fi
 OBJECTID fi
 OBJECTID fi
 OBJECTID fi
 OBJECTID fi
 OBJECTID fi
 OBJECTID i2c
 OBJECTID is
 OBJECTID the
 OBJECTID inverse
 OBJECTID of
 OBJECTID c2i
 OBJECTID i2c
 OBJECTID i
 INT
 STRING
 OBJECTID if
 OBJECTID i
 INT_CONST 0
 OBJECTID then
 INT_CONST 0
 OBJECTID else
 OBJECTID if
 OBJECTID i
 INT_CONST 1
 OBJECTID then
 INT_CONST 1
 OBJECTID else
 OBJECTID if
 OBJECTID i
 INT_CONST 2
 OBJECTID then
 INT_CONST 2
 OBJECTID else
 OBJECTID if
 OBJECTID i
 INT_CONST 3
 OBJECTID then
 INT_CONST 3
 OBJECTID else
 OBJECTID if
 OBJECTID i
 INT_CONST 4
 OBJECTID then
 INT_CONST 4
 OBJECTID else
 OBJECTID if
 OBJECTID i
 INT_CONST 5
 OBJECTID then
 INT_CONST 5
 OBJECTID else
 OBJECTID if
 OBJECTID i
 INT_CONST 6
 OBJECTID then
 INT_CONST 6
 OBJECTID else
 OBJECTID if
 OBJECTID i
 INT_CONST 7
 OBJECTID then
 INT_CONST 7
 OBJECTID else
 OBJECTID if
 OBJECTID i
 INT_CONST 8
 OBJECTID then
 INT_CONST 8
 OBJECTID else
 OBJECTID if
 OBJECTID i
 INT_CONST 9
 OBJECTID then
 INT_CONST 9
 OBJECTID else
 OBJECTID abort
 OBJECTID the
 OBJECTID is
 OBJECTID needed
 OBJECTID to
 OBJECTID satisfy
 OBJECTID the
 OBJECTID typchecker
 OBJECTID fi
 OBJECTID fi
 OBJECTID fi
 OBJECTID fi
 OBJECTID fi
 OBJECTID fi
 OBJECTID fi
 OBJECTID fi
 OBJECTID fi
 OBJECTID fi
 OBJECTID a2i
 OBJECTID converts
 OBJECTID an
 ASCII
 OBJECTID string
 OBJECTID into
 OBJECTID an
 OBJECTID integer
 THE
 OBJECTID empty
 OBJECTID string
 OBJECTID is
 OBJECTID converted
 OBJECTID to
 INT_CONST 0
 SIGNED
 OBJECTID and
 OBJECTID unsigned
 OBJECTID strings
 OBJECTID are
 OBJECTID handled
 THE
 OBJECTID method
 OBJECTID aborts
 OBJECTID if
 OBJECTID the
 OBJECTID string
 OBJECTID does
 OBJECTID not
 OBJECTID represent
 OBJECTID an
 OBJECTID integer
 VERY
 OBJECTID long
 OBJECTID strings
 OBJECTID of
 OBJECTID digits
 OBJECTID produce
 OBJECTID strange
 OBJECTID answers
 OBJECTID because
 OBJECTID of
 OBJECTID arithmetic
 OBJECTID overflow
 OBJECTID a2i
 OBJECTID s
 STRING
 INT
 OBJECTID if
 OBJECTID s
 OBJECTID length
 INT_CONST 0
 OBJECTID then
 INT_CONST 0
 OBJECTID else
 OBJECTID if
 OBJECTID s
 OBJECTID substr
 INT_CONST 0
 INT_CONST 1
 OBJECTID then
 OBJECTID a2i_aux
 OBJECTID s
 OBJECTID substr
 INT_CONST 1
 OBJECTID s
 OBJECTID length
 INT_CONST 1
 OBJECTID else
 OBJECTID if
 OBJECTID s
 OBJECTID substr
 INT_CONST 0
 INT_CONST 1
 OBJECTID then
 OBJECTID a2i_aux
 OBJECTID s
 OBJECTID substr
 INT_CONST 1
 OBJECTID s
 OBJECTID length
 INT_CONST 1
 OBJECTID else
 OBJECTID a2i_aux
 OBJECTID s
 OBJECTID fi
 OBJECTID fi
 OBJECTID fi
 OBJECTID a2i_aux
 OBJECTID converts
 OBJECTID the
 OBJECTID usigned
 OBJECTID portion
 OBJECTID of
 OBJECTID the
 OBJECTID string
 AS
 OBJECTID a
 OBJECTID programming
 OBJECTID example
 OBJECTID this
 OBJECTID method
 OBJECTID is
 OBJECTID written
 OBJECTID iteratively
 OBJECTID a2i_aux
 OBJECTID s
 STRING
 INT
 OBJECTID let
 OBJECTID int
 INT
 ASSIGN
 INT_CONST 0
 OBJECTID in
 OBJECTID let
 OBJECTID j
 INT
 ASSIGN
 OBJECTID s
 OBJECTID length
 OBJECTID in
 OBJECTID let
 OBJECTID i
 INT
 ASSIGN
 INT_CONST 0
 OBJECTID in
 OBJECTID while
 OBJECTID i
 OBJECTID j
 OBJECTID loop
 OBJECTID int
 ASSIGN
 OBJECTID int
 INT_CONST 10
 OBJECTID c2i
 OBJECTID s
 OBJECTID substr
 OBJECTID i
 INT_CONST 1
 OBJECTID i
 ASSIGN
 OBJECTID i
 INT_CONST 1
 OBJECTID pool
 OBJECTID int
 OBJECTID i2a
 OBJECTID converts
 OBJECTID an
 OBJECTID integer
 OBJECTID to
 OBJECTID a
 OBJECTID string
 POSITIVE
 OBJECTID and
 OBJECTID negative
 OBJECTID numbers
 OBJECTID are
 OBJECTID handled
 OBJECTID correctly
 OBJECTID i2a
 OBJECTID i
 INT
 STRING
 OBJECTID if
 OBJECTID i
 INT_CONST 0
 OBJECTID then
 INT_CONST 0
 OBJECTID else
 OBJECTID if
 INT_CONST 0
 OBJECTID i
 OBJECTID then
 OBJECTID i2a_aux
 OBJECTID i
 OBJECTID else
 OBJECTID concat
 OBJECTID i2a_aux
 OBJECTID i
 INT_CONST 1
 OBJECTID fi
 OBJECTID fi
 OBJECTID i2a_aux
 OBJECTID is
 OBJECTID an
 OBJECTID example
 OBJECTID using
 OBJECTID recursion
 OBJECTID i2a_aux
 OBJECTID i
 INT
 STRING
 OBJECTID if
 OBJECTID i
 INT_CONST 0
 OBJECTID then
 OBJECTID else
 OBJECTID let
 OBJECTID next
 INT
 ASSIGN
 OBJECTID i
 INT_CONST 10
 OBJECTID in
 OBJECTID i2a_aux
 OBJECTID next
 OBJECTID concat
 OBJECTID i2c
 OBJECTID i
 OBJECTID next
 INT_CONST 10
 OBJECTID fi
 OBJECTID class
 MAIN
 OBJECTID inherits
 IO
 OBJECTID char
 STRING
 OBJECTID avar
 A
 OBJECTID a_var
 A
 OBJECTID flag
 BOOL
 ASSIGN
 OBJECTID true
 OBJECTID menu
 STRING
 OBJECTID out_string
 OBJECTID n
 OBJECTID tTo
 OBJECTID add
 OBJECTID a
 OBJECTID number
 OBJECTID to
 OBJECTID print
 OBJECTID avar
 OBJECTID out_string
 OBJECTID enter
 OBJECTID a
 OBJECTID n
 OBJECTID out_string
 OBJECTID tTo
 OBJECTID negate
 OBJECTID print
 OBJECTID avar
 OBJECTID out_string
 OBJECTID enter
 OBJECTID b
 OBJECTID n
 OBJECTID out_string
 OBJECTID tTo
 OBJECTID find
 OBJECTID the
 OBJECTID difference
 OBJECTID between
 OBJECTID print
 OBJECTID avar
 OBJECTID out_string
 OBJECTID and
 OBJECTID another
 OBJECTID number
 OBJECTID enter
 OBJECTID c
 OBJECTID n
 OBJECTID out_string
 OBJECTID tTo
 OBJECTID find
 OBJECTID the
 OBJECTID factorial
 OBJECTID of
 OBJECTID print
 OBJECTID avar
 OBJECTID out_string
 OBJECTID enter
 OBJECTID d
 OBJECTID n
 OBJECTID out_string
 OBJECTID tTo
 OBJECTID square
 OBJECTID print
 OBJECTID avar
 OBJECTID out_string
 OBJECTID enter
 OBJECTID e
 OBJECTID n
 OBJECTID out_string
 OBJECTID tTo
 OBJECTID cube
 OBJECTID print
 OBJECTID avar
 OBJECTID out_string
 OBJECTID enter
 OBJECTID f
 OBJECTID n
 OBJECTID out_string
 OBJECTID tTo
 OBJECTID find
 OBJECTID out
 OBJECTID if
 OBJECTID print
 OBJECTID avar
 OBJECTID out_string
 OBJECTID is
 OBJECTID a
 OBJECTID multiple
 OBJECTID of
 INT_CONST 3
 OBJECTID enter
 OBJECTID g
 OBJECTID n
 OBJECTID out_string
 OBJECTID tTo
 OBJECTID divide
 OBJECTID print
 OBJECTID avar
 OBJECTID out_string
 OBJECTID by
 INT_CONST 8
 OBJECTID enter
 OBJECTID h
 OBJECTID n
 OBJECTID out_string
 OBJECTID tTo
 OBJECTID get
 OBJECTID a
 OBJECTID new
 OBJECTID number
 OBJECTID enter
 OBJECTID j
 OBJECTID n
 OBJECTID out_string
 OBJECTID tTo
 OBJECTID quit
 OBJECTID enter
 OBJECTID q
 OBJECTID n
 OBJECTID n
 OBJECTID in_string
 OBJECTID prompt
 STRING
 OBJECTID out_string
 OBJECTID n
 OBJECTID out_string
 PLEASE
 OBJECTID enter
 OBJECTID a
 OBJECTID number
 OBJECTID in_string
 OBJECTID get_int
 INT
 OBJECTID let
 OBJECTID z
 A
 INT_CONST 2
 I
 ASSIGN
 OBJECTID new
 A
 INT_CONST 2
 I
 OBJECTID in
 OBJECTID let
 OBJECTID s
 STRING
 ASSIGN
 OBJECTID prompt
 OBJECTID in
 OBJECTID z
 OBJECTID a2i
 OBJECTID s
 OBJECTID is_even
 OBJECTID num
 INT
 BOOL
 OBJECTID let
 OBJECTID x
 INT
 ASSIGN
 OBJECTID num
 OBJECTID in
 OBJECTID if
 OBJECTID x
 INT_CONST 0
 OBJECTID then
 OBJECTID is_even
 OBJECTID x
 OBJECTID else
 OBJECTID if
 INT_CONST 0
 OBJECTID x
 OBJECTID then
 OBJECTID true
 OBJECTID else
 OBJECTID if
 INT_CONST 1
 OBJECTID x
 OBJECTID then
 OBJECTID false
 OBJECTID else
 OBJECTID is_even
 OBJECTID x
 INT_CONST 2
 OBJECTID fi
 OBJECTID fi
 OBJECTID fi
 OBJECTID class_type
 OBJECTID var
 A
 SELF
 TYPE
 OBJECTID case
 OBJECTID var
 OBJECTID of
 OBJECTID a
 A
 OBJECTID out_string
 CLASS
 OBJECTID type
 OBJECTID is
 OBJECTID now
 A
 OBJECTID n
 OBJECTID b
 B
 OBJECTID out_string
 CLASS
 OBJECTID type
 OBJECTID is
 OBJECTID now
 B
 OBJECTID n
 OBJECTID c
 C
 OBJECTID out_string
 CLASS
 OBJECTID type
 OBJECTID is
 OBJECTID now
 C
 OBJECTID n
 OBJECTID d
 D
 OBJECTID out_string
 CLASS
 OBJECTID type
 OBJECTID is
 OBJECTID now
 D
 OBJECTID n
 OBJECTID e
 E
 OBJECTID out_string
 CLASS
 OBJECTID type
 OBJECTID is
 OBJECTID now
 E
 OBJECTID n
 OBJECTID o
 OBJECT
 OBJECTID out_string
 OOOOPS
 OBJECTID n
 OBJECTID esac
 OBJECTID print
 OBJECTID var
 A
 SELF
 TYPE
 OBJECTID let
 OBJECTID z
 A
 INT_CONST 2
 I
 ASSIGN
 OBJECTID new
 A
 INT_CONST 2
 I
 OBJECTID in
 OBJECTID out_string
 OBJECTID z
 OBJECTID i2a
 OBJECTID var
 OBJECTID value
 OBJECTID out_string
 OBJECTID main
 OBJECT
 OBJECTID avar
 ASSIGN
 OBJECTID new
 A
 OBJECTID while
 OBJECTID flag
 OBJECTID loop
 OBJECTID avar
 ASSIGN
 OBJECTID new
 A
 OBJECTID set_var
 OBJECTID get_int
 OBJECTID out_string
 OBJECTID number
 OBJECTID print
 OBJECTID avar
 OBJECTID if
 OBJECTID is_even
 OBJECTID avar
 OBJECTID value
 OBJECTID then
 OBJECTID out_string
 OBJECTID is
 OBJECTID even
 OBJECTID n
 OBJECTID else
 OBJECTID out_string
 OBJECTID is
 OBJECTID odd
 OBJECTID n
 OBJECTID fi
 OBJECTID print
 OBJECTID avar
 OBJECTID prints
 OBJECTID out
 OBJECTID answer
 OBJECTID class_type
 OBJECTID avar
 OBJECTID char
 ASSIGN
 OBJECTID menu
 OBJECTID if
 OBJECTID char
 OBJECTID a
 OBJECTID then
 OBJECTID add
 OBJECTID a_var
 ASSIGN
 OBJECTID new
 A
 OBJECTID set_var
 OBJECTID get_int
 OBJECTID avar
 ASSIGN
 OBJECTID new
 B
 OBJECTID method2
 OBJECTID avar
 OBJECTID value
 OBJECTID a_var
 OBJECTID value
 OBJECTID else
 OBJECTID if
 OBJECTID char
 OBJECTID b
 OBJECTID then
 OBJECTID negate
 OBJECTID case
 OBJECTID avar
 OBJECTID of
 OBJECTID c
 C
 OBJECTID avar
 ASSIGN
 OBJECTID c
 OBJECTID method6
 OBJECTID c
 OBJECTID value
 OBJECTID a
 A
 OBJECTID avar
 ASSIGN
 OBJECTID a
 OBJECTID method3
 OBJECTID a
 OBJECTID value
 OBJECTID o
 OBJECT
 OBJECTID out_string
 OOOOPS
 OBJECTID n
 OBJECTID abort
 INT_CONST 0
 OBJECTID esac
 OBJECTID else
 OBJECTID if
 OBJECTID char
 OBJECTID c
 OBJECTID then
 OBJECTID diff
 OBJECTID a_var
 ASSIGN
 OBJECTID new
 A
 OBJECTID set_var
 OBJECTID get_int
 OBJECTID avar
 ASSIGN
 OBJECTID new
 D
 OBJECTID method4
 OBJECTID avar
 OBJECTID value
 OBJECTID a_var
 OBJECTID value
 OBJECTID else
 OBJECTID if
 OBJECTID char
 OBJECTID d
 OBJECTID then
 OBJECTID avar
 ASSIGN
 OBJECTID new
 C
 A
 OBJECTID method5
 OBJECTID avar
 OBJECTID value
 OBJECTID else
 OBJECTID factorial
 OBJECTID if
 OBJECTID char
 OBJECTID e
 OBJECTID then
 OBJECTID avar
 ASSIGN
 OBJECTID new
 C
 B
 OBJECTID method5
 OBJECTID avar
 OBJECTID value
 OBJECTID else
 OBJECTID square
 OBJECTID if
 OBJECTID char
 OBJECTID f
 OBJECTID then
 OBJECTID avar
 ASSIGN
 OBJECTID new
 C
 C
 OBJECTID method5
 OBJECTID avar
 OBJECTID value
 OBJECTID else
 OBJECTID cube
 OBJECTID if
 OBJECTID char
 OBJECTID g
 OBJECTID then
 OBJECTID multiple
 OBJECTID of
 INT_CONST 3
 OBJECTID if
 OBJECTID new
 D
 OBJECTID method7
 OBJECTID avar
 OBJECTID value
 OBJECTID then
 OBJECTID avar
 ASSIGN
 OBJECTID new
 A
 OBJECTID method1
 OBJECTID avar
 OBJECTID value
 OBJECTID out_string
 OBJECTID number
 OBJECTID print
 OBJECTID avar
 OBJECTID out_string
 OBJECTID is
 OBJECTID divisible
 OBJECTID by
 INT_CONST 3
 OBJECTID n
 OBJECTID else
 OBJECTID avar
 ASSIGN
 OBJECTID new
 A
 OBJECTID set_var
 INT_CONST 0
 OBJECTID out_string
 OBJECTID number
 OBJECTID print
 OBJECTID avar
 OBJECTID out_string
 OBJECTID is
 OBJECTID not
 OBJECTID divisible
 OBJECTID by
 INT_CONST 3
 OBJECTID n
 OBJECTID fi
 OBJECTID else
 OBJECTID if
 OBJECTID char
 OBJECTID h
 OBJECTID then
 OBJECTID let
 OBJECTID x
 A
 OBJECTID in
 OBJECTID x
 ASSIGN
 OBJECTID new
 E
 OBJECTID method6
 OBJECTID avar
 OBJECTID value
 OBJECTID let
 OBJECTID r
 INT
 ASSIGN
 OBJECTID avar
 OBJECTID value
 OBJECTID x
 OBJECTID value
 INT_CONST 8
 OBJECTID in
 OBJECTID out_string
 OBJECTID number
 OBJECTID print
 OBJECTID avar
 OBJECTID out_string
 OBJECTID is
 OBJECTID equal
 OBJECTID to
 OBJECTID print
 OBJECTID x
 OBJECTID out_string
 OBJECTID times
 INT_CONST 8
 OBJECTID with
 OBJECTID a
 OBJECTID remainder
 OBJECTID of
 OBJECTID let
 OBJECTID a
 A
 INT_CONST 2
 I
 ASSIGN
 OBJECTID new
 A
 INT_CONST 2
 I
 OBJECTID in
 OBJECTID out_string
 OBJECTID a
 OBJECTID i2a
 OBJECTID r
 OBJECTID out_string
 OBJECTID n
 OBJECTID end
 OBJECTID let
 OBJECTID a
 OBJECTID end
 OBJECTID let
 OBJECTID r
 OBJECTID avar
 ASSIGN
 OBJECTID x
 OBJECTID end
 OBJECTID let
 OBJECTID x
 OBJECTID else
 OBJECTID if
 OBJECTID char
 OBJECTID j
 OBJECTID then
 OBJECTID avar
 ASSIGN
 OBJECTID new
 A
 OBJECTID else
 OBJECTID if
 OBJECTID char
 OBJECTID q
 OBJECTID then
 OBJECTID flag
 ASSIGN
 OBJECTID false
 OBJECTID else
 OBJECTID avar
 ASSIGN
 OBJECTID new
 A
 OBJECTID method1
 OBJECTID avar
 OBJECTID value
 OBJECTID divide
 INT_CONST 8
 OBJECTID fi
 OBJECTID fi
 OBJECTID fi
 OBJECTID fi
 OBJECTID fi
 OBJECTID fi
 OBJECTID fi
 OBJECTID fi
 OBJECTID fi
 OBJECTID fi
 OBJECTID pool